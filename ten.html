Principle #10: Simplicity—the Art of Maximizing the Amount of Work Not Done—Is Essential. Adding code to an existing
project often makes it more complex, especially when you then add even more code that depends on it. Dependencies
between systems, objects, services, etc., make code more complex and difficult to change: the dependencies increase the
likelihood of one change cascading out to another part of the system, which then requires changes to a third part of the
system, creating a domino effect of increasing complexity for every change. Using iteration and building the minimal
documentation at the start of the project helps your team avoid delivering unnecessary software. However, a lot of
developers feel a little uncomfortable when they first hear phrases like “use iterative development,” and “do the
minimal amount of planning needed to start the project.” They feel like it’s too early to start the code for a project
until they’ve made a lot of the design and architecture decisions and written them down—otherwise the team will write
code today that they’ll need remove tomorrow when the design changes. This is an understandable reaction, because for
many projects outside the realm of software development, this wouldn’t make sense. It’s not uncommon for a programmer
who’s new to agile to raise an objection like this: “If I’m having a contractor renovate my house, I want to see the
complete blueprints first. I don’t want him to have a quick discussion with me, and then start knocking down my walls.”
This argument makes sense for home renovation. The reason is that when you’re making a change to a house, the most
destructive thing you can do is pick up a sledgehammer and break down a wall. But software projects are different from
houses or other physical objects. Deleting code is not particularly destructive, because you can usually just recover it
from the version control system. The most destructive thing you can do to your project is to build new code, and then
build more code that depends on it, and then still more code that depends on that, leading to that painfully familiar
domino effect of cascading changes...and eventually leaving you with an unmaintainable mess of spaghetti code.
Maximizing the amount of work not done means avoiding this mess—and the best way to do this is by building systems that
don’t have a lot of dependencies and unnecessary code. The most effective way to do this is to work with your customers
and stakeholders to only build the most useful and valuable software. If a feature is not valuable, it’s often cheaper
for the company in the long run to not build it at all, because the cost of maintaining the additional code is actually
higher than the value it delivers to the company. When teams write code, they can keep their software designs simple by
creating software designs based on small, self-contained units (like classes, modules, services, etc.) that do only one
thing; this helps avoid the domino effect.6
